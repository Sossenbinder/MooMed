Yes, what you are looking for is end to end encrypted chats, i hope youre not looking for group chats though, that's a little more interesting.

Asymmetric encryption means that you have 2 keys, one private and on epublic key (just priv and pub for the future) The pub key can be used in order to decrypt a message which has previously been encrypted with the pub key. This means that every person can know the pub key (hence its name) because it is not a security risk as it can only encrypt. This is because it is consider computationally expesnive (so expensive its practically impossible...without quantum computers which is why security people are afraid of them) to deduce the priv key from the pub key. Furthermore asymmetric encryption has another nice property, given a function encrypt(pub, message) and a function decrypt(priv, encrypted) you can be sure that decrypt(priv, encrypt(pub, message)) == message (this is the normal encrypt, decrypt relation i just explained) the order of encrypt and decrypt does not matter htough, hence encrypt(pub, decrypt(priv, message)) == message. One might wonder how this can be useful but this means that if message is a thing that is known to one of the owners of your pub key. We can use this property in combination with so called cryptographic hashing functions. A hash function is a function that maps a arbitrarily sized message on to a fixed size message (so for example, any message to 256 bit), the "cryptographic" part about this relation means that from hash(message) you cannot deduce message (again, you can its just computationally too expensive) anymore. What this means is that along with our encrypted message we can send decrypt(priv, hash(message)) + hash(message), then the the receiver can check whether encrypt(pub, decrypt(priv, hash(message)) is equal to hash(message).
As only the owner of the private key can create the value decrypt(priv, hash(message))  we have just proven that this message comes from the owner of the private key (this is called a digital signature).

And with this little crash course in crypo we can come up with:

1. Create a mechanism that produces a new pub priv key pair per device (the priv key should neve rleave the device) and then uploads the pub key to the server
2. If a user wants to send anothe ruser a message they request all public keys of the other user and encrypt their message with them
3. They send a signature witht heir private key (and the id of the pub key)
4. The receiving user fetches the message from the server, verifies the signature and decrypts the message
5. profit